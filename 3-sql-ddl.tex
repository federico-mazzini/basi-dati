\documentclass{beamer}

\usetheme{Madrid}
\usecolortheme{default}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor} 
\usepackage{colortbl}
\usepackage{verbatim}

\title{Basi di Dati}
\subtitle{SQL DDL -- Definizione delle strutture}
\author{Prof. Federico Mazzini, Prof.ssa Francesca Larotonda}
\institute{I.I.S. Francesco Alberghetti}
\date{A.S. 2025 -- 2026}

\begin{document}

%==============================================================================
\begin{frame}
\titlepage
\end{frame}

%==============================================================================
\section{SQL DDL (Data Definition Language)}
%==============================================================================

\begin{frame}{Dal modello relazionale al database}
Fino ad ora abbiamo costruito \textbf{uno schema relazionale}:
\begin{itemize}
    \item definito le \textbf{relazioni} (tabelle) che rappresentano entità o concetti del mondo reale;
    \item stabilito gli \textbf{attributi} di ciascuna relazione;
    \item definito i \textbf{vincoli di integrità intra-relazionali} (es. dominio, non nullità) e \textbf{inter-relazionali} (foreign key).
    \item individuato \textbf{chiavi primarie} e \textbf{chiavi esterne}
\end{itemize}

\medskip
\alert{Ora dobbiamo trasferire tutto questo in un database reale, usando un linguaggio che il DBMS possa comprendere.}
\end{frame}

%==============================================================================
\begin{frame}{Comunicare con il DBMS}
Il DBMS ha bisogno di \textbf{istruzioni formali e precise}.

\medskip
Per questo usiamo un linguaggio standard per la definizione dei dati: \textbf{SQL}.

\medskip
SQL permette di passare dalle relazioni definite su carta a:
\begin{itemize}
    \item creare le tabelle;
    \item definire gli attributi e i tipi di dato;
    \item specificare chiavi primarie e vincoli di integrità.
\end{itemize}
\end{frame}

%==============================================================================
\begin{frame}{SQL}
\begin{block}{Definizione}
SQL (Structured Query Language) è il linguaggio standard per comunicare con i database relazionali.
\end{block}

\begin{itemize}
    \item È un linguaggio \textbf{dichiarativo}: descrive \textbf{cosa} vogliamo ottenere, non \textbf{come} calcolarlo.
    \item Diverso dalla programmazione procedurale o a oggetti che abbiamo visto finora, dove scriviamo passo passo le istruzioni.
    \item È utilizzato da tutti i principali DBMS.
\end{itemize}
\end{frame}

%==============================================================================
\begin{frame}{SQL e DBMS}
SQL è uno standard, ma ogni DBMS ha delle varianti.

\medskip
In questo corso utilizziamo \textbf{MariaDB}:

\begin{itemize}
    \item usato tramite phpMyAdmin (interfaccia web);
    \item con sintassi e tipi di dato specifici.
\end{itemize}

I concetti chiave di SQL rimangono gli stessi, cambiano solamente alcune sintassi specifiche.
\end{frame}

%==============================================================================
\begin{frame}{SQL e funzionalità}
SQL è suddiviso in parti:
\begin{itemize}
    \item \textbf{DDL} -- Data Definition Language;
    \item DML -- Data Manipulation Language;
    \item DQL -- Data Query Language.
\end{itemize}

\medskip
In questo modulo ci concentriamo su SQL DDL.

\begin{block}{Definizione}
Il DDL è la parte di SQL che serve per \textbf{definire e modificare la struttura del database}. Permette di tradurre il modello relazionale in istruzioni per il DBMS.
\end{block}

\end{frame}

%==============================================================================
\begin{frame}{Panoramica SQL DDL}
Il DDL permette di definire e organizzare la struttura dei dati nel database.
\medskip

\begin{itemize}
    \item \textbf{Database}: creare e cancellare database
        \begin{itemize}
            \item \texttt{CREATE DATABASE}
            \item \texttt{DROP DATABASE}
        \end{itemize}

    \item \textbf{Tabelle}: creare, modificare e cancellare tabelle
        \begin{itemize}
            \item \texttt{CREATE TABLE}
            \item \texttt{ALTER TABLE} (aggiungere/modificare colonne o vincoli)
            \item \texttt{DROP TABLE}
        \end{itemize}

    \item \textbf{Vincoli e integrità}: definire regole per i dati
        \begin{itemize}
            \item Chiavi primarie e uniche (\texttt{PRIMARY KEY}, \texttt{UNIQUE})
            \item Chiavi esterne (\texttt{FOREIGN KEY})
            \item Vincoli su valori (\texttt{CHECK}, \texttt{NOT NULL}, \texttt{DEFAULT})
        \end{itemize}

    \item \textbf{Indici e ottimizzazione}: migliorare performance
        \begin{itemize}
            \item \texttt{CREATE INDEX}, \texttt{DROP INDEX}
        \end{itemize}
\end{itemize}
\end{frame}

%==============================================================================
\subsection{CREATE}
%==============================================================================

\begin{frame}{CREATE}
Il comando \textbf{CREATE} serve per creare nuovi oggetti nel database:
\begin{itemize}
    \item tabelle;
    \item database;
    \item viste;
    \item indici.
\end{itemize}
\end{frame}


%==============================================================================
\begin{frame}[fragile]{CREATE DATABASE}
\begin{block}{Sintassi Base}
\begin{verbatim}
CREATE DATABASE nome_database;
USE nome_database;
\end{verbatim}
\end{block}
\end{frame}


%==============================================================================
\begin{frame}[fragile]{CREATE TABLE}
Esempio concreto di tabella “studenti”:

\begin{block}{Esempio}
\begin{verbatim}
CREATE TABLE studente (
    matricola INT PRIMARY KEY,
    nome VARCHAR(50) NOT NULL,
    cognome VARCHAR(50) NOT NULL,
    data_nascita DATE,
    classe VARCHAR(10)
);
\end{verbatim}
\end{block}

\begin{itemize}
    \item Tabella: \texttt{studente}
    \item Attributi: nome, cognome, matricola, data\_nascita, classe
    \item Vincoli: \texttt{PRIMARY KEY, NOT NULL}
\end{itemize}
\end{frame} 

%==============================================================================
\begin{frame}[fragile]{CREATE TABLE}
\begin{block}{Sintassi generale}
\begin{verbatim}
CREATE TABLE nome_tabella (
    attributo1 tipo_dato [vincoli],
    attributo2 tipo_dato [vincoli],
    ...
    [vincoli_tabella] 
);
\end{verbatim}
\end{block}

\begin{itemize}
    \item \textbf{tipo\_dato}: INT, VARCHAR, DATE, DECIMAL, ecc.
    \item \textbf{vincoli}: PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT
    \item Vincoli tabella: coinvolgono più colonne (es. chiave esterna)
\end{itemize}
\end{frame}

%==============================================================================
\subsection{Tipi di dato}
%==============================================================================
\begin{frame}{Tipi di dato in SQL}
Ogni colonna deve avere un tipo di dato che definisce valori ammessi, spazio occupato e operazioni possibili.

\medskip
\textbf{Tipi principali:}
\begin{itemize}
    \item \textbf{Numerici:} \texttt{INT}, \texttt{SMALLINT}, \texttt{BIGINT}, \texttt{DECIMAL(p,s)}
    \item \textbf{Testuali:} \texttt{CHAR(n)}, \texttt{VARCHAR(n)}, \texttt{TEXT}
    \item \textbf{Temporali:} \texttt{DATE}, \texttt{TIME}, \texttt{DATETIME}
\end{itemize}

\medskip
\textbf{Esempi pratici:}
\begin{itemize}
    \item CodiceFiscale $\rightarrow$ \texttt{CHAR(16)}
    \item Nome, Cognome $\rightarrow$ \texttt{VARCHAR}
    \item Prezzo $\rightarrow$ \texttt{DECIMAL}
\end{itemize}

\medskip
\alert{Il tipo di dato deve riflettere il significato dell’informazione.}
\end{frame}
%==============================================================================
\subsection{Vincoli (Constraints)}
%==============================================================================

\begin{frame}[fragile]{Vincoli (CONSTRAINTS)}
I vincoli garantiscono l’integrità dei dati e la coerenza tra le tabelle.

\begin{itemize}
    \item \texttt{PRIMARY KEY} -- identifica univocamente le righe
    \item \texttt{FOREIGN KEY} -- garantisce la referenzialità tra tabelle
    \item \texttt{UNIQUE} -- valori non ripetuti
    \item \texttt{NOT NULL} -- valore obbligatorio
    \item \texttt{CHECK} -- condizione su valori
\end{itemize}

\medskip
\alert{Si possono dichiarare subito nella \texttt{CREATE TABLE} oppure aggiungere in seguito con \texttt{ALTER TABLE}.}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{PRIMARY KEY}
\small
\textbf{Dentro CREATE TABLE:}
\begin{verbatim}
CREATE TABLE studente (
    matricola INT PRIMARY KEY,
    nome VARCHAR(50),
    cognome VARCHAR(50)
);
\end{verbatim}

\textbf{Dopo la creazione con ALTER TABLE:}
\begin{verbatim}
ALTER TABLE studente
ADD PRIMARY KEY (matricola);
\end{verbatim}

\medskip
\begin{itemize}
    \item identifica univocamente ogni riga;
    \item non può essere NULL.
\end{itemize}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{FOREIGN KEY}
\small
\textbf{Dentro CREATE TABLE:}
\begin{verbatim}
CREATE TABLE iscrizione (
    matricola INT,
    corso_id INT,
    FOREIGN KEY (matricola) REFERENCES studente(matricola)
);
\end{verbatim}

\textbf{Dopo la creazione con ALTER TABLE:}
\begin{verbatim}
ALTER TABLE iscrizione
ADD FOREIGN KEY (matricola) REFERENCES studente(matricola);
\end{verbatim}

\medskip
\begin{itemize}
    \item garantisce la referenzialità;
    \item impedisce riferimenti a dati inesistenti.
\end{itemize}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{NOT NULL e UNIQUE}
\small
\textbf{Dentro CREATE TABLE:}
\begin{verbatim}
CREATE TABLE studente (
    nome VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);
\end{verbatim}

\textbf{Dopo la creazione con ALTER TABLE:}
\begin{verbatim}
ALTER TABLE studente
MODIFY nome VARCHAR(50) NOT NULL;

ALTER TABLE studente
ADD UNIQUE (email);
\end{verbatim}

\medskip 
\begin{itemize}
    \item \texttt{NOT NULL}: valore obbligatorio;
    \item \texttt{UNIQUE}: valori non ripetuti.
\end{itemize}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{CHECK}
\small
\textbf{Dentro CREATE TABLE:}
\begin{verbatim}
CREATE TABLE studente (
    eta INT CHECK (eta >= 18)
);
\end{verbatim}

\textbf{Dopo la creazione con ALTER TABLE:}
\begin{verbatim}
ALTER TABLE studente
ADD CHECK (eta >= 18);
\end{verbatim}

\end{frame}

%==============================================================================
\begin{frame}[fragile]{AUTO\_INCREMENT}
\small
\textbf{Dentro CREATE TABLE:}
\begin{verbatim}
CREATE TABLE studente (
    matricola INT AUTO_INCREMENT,
    nome VARCHAR(50) NOT NULL,
    cognome VARCHAR(50) NOT NULL,
    PRIMARY KEY (matricola)
);
\end{verbatim}

\textbf{Dopo la creazione con ALTER TABLE:}
\begin{verbatim}
ALTER TABLE studente
MODIFY matricola INT AUTO_INCREMENT;
\end{verbatim}

\medskip
\alert{Il DBMS genera automaticamente la chiave primaria senza doverla specificare manualmente.}
\end{frame}

%==============================================================================
\subsection{DROP e ALTER}
%==============================================================================

\begin{frame}[fragile]{DROP}
\small
\begin{verbatim}
DROP TABLE studente;
\end{verbatim}

\medskip
\alert{Comando irreversibile: struttura e dati vengono eliminati.}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{ALTER TABLE}
\small 
\begin{verbatim}
ALTER TABLE studente ADD email VARCHAR(100);
ALTER TABLE studente MODIFY cognome VARCHAR(100);
ALTER TABLE studente DROP COLUMN email;
\end{verbatim}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{ALTER TABLE e dati esistenti}
\begin{itemize}
    \item la tabella può contenere dati;
    \item i vincoli vengono controllati;
    \item alcune modifiche possono fallire.
\end{itemize}

\alert{DDL lavora sulla struttura, ma può impattare sui dati.}
\end{frame}

%==============================================================================
\section{Naming Convention}
%==============================================================================

\begin{frame}{Naming Convention}
Per "naming convention" si intende l'utilizzo di regole per assegnare nomi coerenti e significativi. Rende il database leggibile, manutenibile e comprensibile anche da altri sviluppatori o dal “noi del futuro”.

\medskip
Una buona naming convention convenzione aiuta a:
\begin{itemize}
    \item capire subito cosa rappresenta ogni tabella o colonna;
    \item evitare ambiguità nei join e nelle query;
    \item ridurre errori dovuti a nomi riservati dei DBMS (create, select, group).
\end{itemize}

\end{frame} 


%==============================================================================
\begin{frame}{Regola principale: snake\_case}
In SQL moderno si usa quasi sempre lo stile \textbf{snake\_case} per tabelle e colonne:
\begin{itemize}
    \item tutti i nomi in \textbf{minuscolo};
    \item usare l'underscore \_ per separare le parole;
    \item evitare spazi e caratteri speciali.
\end{itemize}

\medskip
\textbf{Esempi:}
\begin{itemize}
    \item studenti, professori, voti
    \item data\_nascita, cod\_materia
    \item creato\_il, aggiornato\_il
\end{itemize}

\medskip
Evitare: FirstName, creatoIl, STUDENTS, Order-Info.

\end{frame}

%==============================================================================

\section{Esempio}
%==============================================================================
\begin{frame}{Esempio: Database Scuola}
\textbf{Obiettivo}: creare un database per gestire le informazioni di una scuola superiore.

\medskip
\textbf{Modello logico relazionale}
\begin{itemize}
    \item \textbf{Studente}(\underline{Matricola}, Nome, Cognome, DataNascita)
    \item \textbf{Professore}(\underline{CodFiscale}, Nome, Cognome)
    \item \textbf{Materia}(\underline{CodMateria}, NomeMateria)
    \item \textbf{Lezione}(\underline{idLezione}, CodMateria, CodFiscale, Giorno, Orario)
    \item \textbf{Voto}(\underline{idVoto}, Matricola, CodMateria, Voto, DataVoto)
\end{itemize}

\medskip 
\textbf{Vincoli di integrità referenziale:}
\begin{itemize}
    \item Lezione.CodMateria → Materia.CodMateria
    \item Lezione.CodFiscale → Professore.CodFiscale
    \item Voto.Matricola → Studente.Matricola
    \item Voto.CodMateria → Materia.CodMateria
\end{itemize}

\end{frame}

%==============================================================================
\begin{frame}[fragile]{Creazione tabelle principali}
\small
\textbf{Tabella studente:}
\begin{verbatim}
CREATE TABLE studente (
    matricola INT AUTO_INCREMENT,
    nome VARCHAR(50) NOT NULL,
    cognome VARCHAR(50) NOT NULL,
    data_nascita DATE,
    PRIMARY KEY (matricola)
);
\end{verbatim}

\textbf{Tabella professore:}
\begin{verbatim}
CREATE TABLE professore (
    cod_fiscale CHAR(16) PRIMARY KEY,
    nome VARCHAR(50) NOT NULL,
    cognome VARCHAR(50) NOT NULL
);
\end{verbatim}
\end{frame}
%==============================================================================
\begin{frame}[fragile]{Creazione tabelle principali}
\small
\textbf{Tabella materia:}
\begin{verbatim}
CREATE TABLE materia (
    cod_materia CHAR(5) PRIMARY KEY,
    nome_materia VARCHAR(50) NOT NULL
);
\end{verbatim}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{Creazione tabelle relazionali}
\small
\textbf{Tabella lezione:}
\begin{verbatim}
CREATE TABLE lezione (
    id_lezione INT AUTO_INCREMENT,
    cod_materia CHAR(5),
    cod_fiscale CHAR(16),
    giorno DATE,
    orario TIME,
    PRIMARY KEY (id_lezione),
    FOREIGN KEY (cod_materia) REFERENCES materia(cod_materia),
    FOREIGN KEY (cod_fiscale) REFERENCES professore(cod_fiscale)
);
\end{verbatim}
\end{frame}
%==============================================================================
\begin{frame}[fragile]{Creazione tabelle relazionali}
\small

\textbf{Tabella voto:}
\begin{verbatim}
CREATE TABLE voto (
    id_voto INT AUTO_INCREMENT,
    matricola INT,
    cod_materia CHAR(5),
    voto DECIMAL(4,2),
    data_voto DATE,
    PRIMARY KEY (id_voto),
    FOREIGN KEY (matricola) REFERENCES studente(matricola),
    FOREIGN KEY (cod_materia) REFERENCES materia(cod_materia)
);
\end{verbatim}
\end{frame}

%==============================================================================
\begin{frame}[fragile]{Aggiungere vincoli dopo la creazione}
\small
\textbf{ALTER TABLE esempio: aggiungere foreign key}

\begin{verbatim}
ALTER TABLE lezione
ADD FOREIGN KEY (cod_materia) REFERENCES materia(cod_materia);

ALTER TABLE voto
ADD FOREIGN KEY (matricola) REFERENCES studente(matricola);
\end{verbatim}

\medskip
\alert{Si può aggiungere vincoli anche in un secondo momento, se non li si definisce subito nella CREATE TABLE.}
\end{frame}

\end{document}
