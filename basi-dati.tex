\documentclass[a4paper,12pt]{article}

% Lingua e codifica
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}

% Impaginazione e matematica
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{array}
\usepackage{hyperref}
\usepackage{tikz}              % Pacchetto principale per i disegni
\usetikzlibrary{arrows.meta}   % Per frecce avanzate (tipo freccia piena o tratteggiata)
\usetikzlibrary{positioning}   % Per posizionare i nodi rispetto ad altri nodi
\usetikzlibrary{shapes}        % Per avere nodi con forme arrotondate, rettangoli, cerchi, ecc.
\usetikzlibrary{backgrounds,decorations.pathreplacing,calc}

% Comandi utili
\newcommand{\code}[1]{\texttt{#1}}



\begin{document}

\begin{titlepage}
\centering
{\Large I.I.S. ``Francesco Alberghetti'' -- Imola}\\[0.3cm]
{\normalsize Informatica -- Basi di Dati}\\[2cm]

\rule{0.9\textwidth}{0.6pt}\\[0.8cm]

{\huge\bfseries BASI DI DATI RELAZIONALI}\\[0.4cm]
{\Large Dispense complete su DBMS e Modello Relazionale}\\[0.6cm]

\rule{0.9\textwidth}{0.6pt}\\[2cm]

{\large Materiale per lo studio approfondito}\\[1.5cm]

\vfill
{\large Prof. Federico Mazzini}\\
{\large A.S. 2025--2026}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introduzione ai sistemi informativi e ai database}
Le basi di dati costituiscono l’infrastruttura invisibile della società digitale moderna.  
Ogni applicazione informatica che gestisce informazioni persistenti --- dal registro elettronico ai social network, dai sistemi bancari alle piattaforme di streaming --- si basa su una o più basi di dati.

Studiare le basi di dati significa capire:
\begin{itemize}
\item come vengono memorizzate le informazioni;
\item come vengono mantenute corrette nel tempo;
\item come possono essere interrogate in modo efficiente;
\item come vengono protette da errori e accessi non autorizzati.
\end{itemize}

Questa disciplina non riguarda solo la programmazione, ma il \textbf{modo in cui rappresentiamo la realtà} all’interno di un sistema informatico.
%==============================================================================
\subsection{Dato e Informazione}
%==============================================================================

Per iniziare lo studio delle basi di dati, è fondamentale chiarire la differenza tra due concetti che spesso vengono confusi: il dato e l'informazione.

Un \textbf{dato} è una rappresentazione oggettiva e non interpretata della realtà. Può essere un numero, una stringa di testo, un simbolo o un'immagine. Di per sé, il dato non ha un significato completo perché manca di contesto. Ad esempio, se scriviamo il numero "8" su un foglio, questo è un dato puro, ma non sappiamo se indica un orario, un voto scolastico o una quantità.

L'\textbf{informazione}, invece, è ciò che otteniamo quando interpretiamo un dato all'interno di un contesto specifico. È il dato che arricchisce la nostra conoscenza. Tornando all'esempio precedente, se specifichiamo che "8" è il voto preso nella verifica di Informatica da uno studente specifico, abbiamo trasformato il dato in informazione.

Le basi di dati si occupano principalmente di memorizzare e gestire i dati, ma il loro obiettivo finale è fornire informazioni utili agli utenti.

%==============================================================================
\subsection{Sistemi Informativi e Sistemi Informatici}
%==============================================================================

Un \textbf{Sistema Informativo (SI)} è l’insieme delle risorse, delle procedure e delle persone che un’organizzazione (come un’azienda, una scuola o un ente pubblico) utilizza per raccogliere, archiviare ed elaborare le informazioni necessarie alle sue attività. È importante notare che un sistema informativo esiste a prescindere dall’uso dei computer: anche un archivio cartaceo gestito a mano è un sistema informativo.

Per capire meglio a cosa serve, immaginiamo di avere un’azienda che produce scarpe. Il nostro sistema informativo diventa uno strumento fondamentale per gestire tutto ciò che riguarda l’attività aziendale. Ad esempio, possiamo memorizzare informazioni sui clienti: chi sono, cosa hanno comprato, quali taglie preferiscono. Possiamo gestire i dipendenti: dati anagrafici, ruoli, orari di lavoro, stipendi. Possiamo monitorare i prodotti: tipi di scarpe, materiali, colori disponibili, quantità in magazzino. Possiamo tenere traccia dei fornitori: chi ci fornisce i materiali, prezzi, tempi di consegna. Infine, possiamo registrare gli acquisti e le vendite, così da sapere sempre quanto abbiamo venduto e cosa dobbiamo riordinare.

In pratica, il sistema informativo è la “mappa” completa di tutte le informazioni necessarie per prendere decisioni rapide e corrette. Senza di esso, sarebbe difficile sapere se abbiamo abbastanza scarpe in magazzino, quali modelli sono più venduti o quali fornitori sono più affidabili.


\begin{center}
\resizebox{0.95\textwidth}{!}{
\begin{tikzpicture}[node distance=2cm, every node/.style={draw, rounded corners, align=center, minimum width=3cm, minimum height=1cm}]
    % Nodo centrale
    \node[fill=yellow!30] (Azienda) {Azienda di Scarpe\\Sistema Informativo};
    
    % Nodi sopra
    \node [above left=of Azienda, fill=green!20] (Fornitori) {Fornitori\\(chi, prezzi, consegne)};
    \node [above right=of Azienda, fill=green!20] (Marketing) {Marketing\\(promozioni, pubblicità)};
    
    % Nodi sotto
    \node [below left=of Azienda, fill=green!20] (Clienti) {Clienti\\(dati anagrafici, acquisti, preferenze)};
    \node [below=of Azienda, fill=green!20] (Dipendenti) {Dipendenti\\(orari, ruoli, stipendi)};
    \node [below right=of Azienda, fill=green!20] (Prodotti) {Prodotti\\(modelli, materiali, quantità)};
    \node [left=of Clienti, xshift=-2.5cm, fill=green!20] (Acquisti) {Acquisti e Vendite\\(quantità vendute, riordini)};
    
    % Frecce dal nodo centrale
    \draw[->, thick] (Azienda) -- (Fornitori);
    \draw[->, thick] (Azienda) -- (Marketing);
    \draw[->, thick] (Azienda) -- (Clienti);
    \draw[->, thick] (Azienda) -- (Dipendenti);
    \draw[->, thick] (Azienda) -- (Prodotti);
    \draw[->, thick] (Azienda) -- (Acquisti);
\end{tikzpicture}
}
\end{center}

Un \textbf{Sistema Informatico}, invece, è la parte del sistema informativo che viene gestita in modo automatico attraverso tecnologie digitali, cioè computer, software e reti. Oggi, quando parliamo di basi di dati, ci riferiamo proprio a sistemi informatici che permettono di raccogliere, archiviare e analizzare grandi quantità di informazioni in modo veloce e sicuro. Tuttavia, è bene ricordare che la logica di gestione delle informazioni nasce molto prima dei computer: l’idea di organizzare, registrare e consultare dati è un concetto antico, i sistemi informatici hanno aumentato la velocità e la disponibilità con cui è possibile utilizzare i sistemi informativi.


⸻

%==============================================================================
\subsection{L'evoluzione della gestione dei dati}
%==============================================================================

Fino a migliaia di anni fa i romani utilizzano tavole di ... per registrare censimenti (+ fare altri esempi). Fino all'arrivo dei computer e del digitale, ogni azienda aveva il proprio sistema informativo completamente su carta, all'interno di archivi cartacei all'interno degli uffici dell'azienda stessa. La tecnologia informatica ha permesso di salvare e utilizzare questi dati tramite i sistemi informatici. 

\subsubsection{L’approccio basato sui File (File System)}
Nei primi sistemi informatici, i dati erano gestiti separatamente da ciascun programma, mediante file dedicati, sia di tipo testuale sia binario. Ad esempio, il software per la gestione degli stipendi conservava i dati dei dipendenti in un file specifico, mentre il programma destinato alla gestione dei corsi di formazione utilizzava un file differente.

Questo approccio risulta semplice e veloce da implementare, ma presenta notevoli limitazioni in termini di gestione e manutenzione dei dati. In contesti di maggiore complessità, come nel caso di un’organizzazione di grandi dimensioni, emergono problematiche significative. Ad esempio, risulta complicato coordinare le informazioni sulle vendite di un prodotto quando i dati dei clienti sono distribuiti su file distinti e, talvolta, su sedi differenti.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/independent-files.png}
    \caption{Ogni applicazione gestisce i propri file in modo indipendente}
\end{figure}

Inoltre, nei sistemi completamente informatizzati odierni, come quelli utilizzati per le transazioni bancarie o per la gestione di piattaforme e-commerce, è necessario garantire requisiti fondamentali quali sicurezza, affidabilità e accesso concorrente da parte di più utenti. Ogni applicazione implementa la sua logica per gestire questi aspetti, il che può portare a inefficienze e a un aumento della complessità del sistema.


\subsubsection{L'approccio DBMS (Database Management System)}
Per gestire tutti i problemi che emergono con i sistemi basati su file, oggi ci si affida a software specializzati chiamati DBMS (Database Management System).
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.45\textwidth]{images/integrated-database-DBMS.png}
    \caption{App che dialogano con un DBMS}
\end{figure}
Questi programmi permettono di organizzare e gestire i dati in maniera professionale, garantendo che tutto sia corretto, aggiornato e accessibile in sicurezza anche a più utenti contemporaneamente. In pratica, il DBMS fa da “gestore centrale” dei dati, evitando confusione, duplicazioni e errori. Ogni applicazione che ha bisogno di dati (come un sito web, un’app bancaria o un sistema di gestione scolastica) si collega al DBMS per leggere o scrivere le informazioni necessarie.

\newpage
%==============================================================================
%==============================================================================
%==============================================================================
\section{Database Management System (DBMS)}
%==============================================================================

Un Database Management System (DBMS) è un software progettato per gestire collezioni di dati in modo affidabile, efficiente e sicuro.  
Per essere utilizzabile in contesti reali (aziendali, scolastici o industriali), un DBMS deve garantire alcune caratteristiche fondamentali, che risolvono i principali problemi della gestione dei dati su larga scala.

\begin{center}
\begin{tikzpicture}[
    node distance=2cm,
    every node/.style={
        draw,
        rounded corners,
        align=center,
        minimum width=3cm,
        minimum height=0.9cm
    }
]

% Nodo centrale
\node[fill=yellow!30] (DBMS) {\textbf{DBMS}\\Database Management System};

% Nodi esterni
\node[above=of DBMS, fill=green!20] (Eff) {Efficienza\\(velocità e grandi volumi di dati)};
\node[right=of DBMS, fill=green!20] (Conc) {Concorrenza\\(più utenti)};
\node[below=of DBMS, fill=green!20] (Aff) {Affidabilità\\(tutto o niente)};
\node[left=of DBMS, fill=green!20] (Sec) {Sicurezza\\(accessi)};

% Frecce
\draw[->, thick] (DBMS) -- (Eff);
\draw[->, thick] (DBMS) -- (Conc);
\draw[->, thick] (DBMS) -- (Aff);
\draw[->, thick] (DBMS) -- (Sec);

\end{tikzpicture}
\end{center}

\subsection{Caratteristiche di un DBMS}
\subsection*{Efficienza}
Un DBMS deve essere in grado di gestire grandi quantità di dati mantenendo tempi di risposta molto ridotti.  
I dati devono essere persistenti, cioè conservati nel tempo anche dopo la chiusura dei programmi o lo spegnimento del sistema, e devono poter essere recuperati rapidamente quando richiesti.

Nella realtà moderna, i volumi di dati possono raggiungere dimensioni enormi. Alcuni esempi indicativi sono:
\begin{itemize}
    \item Amazon Prime: oltre 240 milioni di abbonati;
    \item Facebook: più di 3 miliardi di utenti attivi mensili;
    \item Instagram: oltre 1,3 miliardi di immagini caricate ogni giorno.
\end{itemize}

Anche in presenza di questi volumi, un DBMS deve consentire operazioni rapide, come la ricerca di un contenuto o l’accesso a un profilo utente, senza che l’utente percepisca rallentamenti.

\subsection*{Concorrenza}
Un DBMS deve gestire correttamente l’accesso simultaneo ai dati da parte di più utenti o applicazioni. Se più operazioni vengono eseguite sugli stessi dati nello stesso istante, il rischio è ottenere risultati errati o incoerenti.  

\subsubsection*{Esempio di concorrenza: prelievi simultanei}

Si consideri un sistema informativo bancario in cui due utenti effettuano un prelievo dallo stesso conto corrente nello stesso istante.

\begin{itemize}
    \item Saldo iniziale del conto X: 120 €
    \item Operazione OP1: prelievo di 100 €
    \item Operazione OP2: prelievo di 80 €
\end{itemize}


\begin{center}
\begin{tabular}{c c c}
\toprule
Tempo & Operazione & Valore di X \\
\midrule
$t_1$ & OP1: Leggi $saldo$ & 120 \\
$t_2$ & OP2: Leggi $saldo$ & 120 \\
$t_3$ & OP1: Calcola $saldo - 100$ & 120 \\
$t_4$ & OP2: Calcola $saldo - 80$ & 120 \\
$t_5$ & OP1: Scrivi $saldo finale$ & 20 \\
$t_6$ & OP2: Scrivi $saldo finale$ & 40 \\
\bottomrule
\end{tabular}
\end{center}

\begin{center}
$Saldo finale = 40 \rightarrow ERRORE!$
\end{center}


Il sistema dovrebbe permettere che solamente una delle due operazioni venga completata, poiché il saldo non è sufficiente per entrambe.

Per risolvere questo problema, i DBMS utilizzano meccanismi di controllo della concorrenza che garantiscono che l’esecuzione simultanea delle operazioni produca lo stesso risultato di un’esecuzione una alla volta (seriale).

\subsection*{Affidabilità}
Un DBMS deve garantire che i dati rimangano corretti e coerenti anche in presenza di errori, interruzioni di corrente o arresti improvvisi del sistema.  
Molte operazioni sui dati sono infatti critiche e non possono essere eseguite parzialmente: devono rispettare la regola del \textbf{tutto o niente}.


\subsubsection*{Esempio di concorrenza: prelievi simultanei}
Si consideri un sistema informativo bancario che gestisce il trasferimento di denaro tra due conti correnti. Un trasferimento non è una singola operazione, ma una sequenza di passi che devono essere eseguiti in modo coordinato.

\bigskip
\begin{itemize}
    \item Conto A (mittente): saldo iniziale 500 €
    \item Conto B (destinatario): saldo iniziale 300 €
    \item Importo del trasferimento: 200 €
\end{itemize}
\bigskip
Il trasferimento prevede due operazioni fondamentali:
\begin{itemize}
    \item addebitare 200 € dal conto A;
    \item accreditare 200 € sul conto B.
\end{itemize}
\bigskip
Se il sistema dovesse interrompersi dopo l’addebito ma prima dell’accredito, il database si troverebbe in uno stato non corretto: il denaro risulterebbe sottratto dal conto A ma non accreditato sul conto B.\\\\
Un DBMS affidabile deve garantire che \textbf{solo uno dei due scenari seguenti}:
\begin{itemize}
    \item entrambe le operazioni vengano completate correttamente;
    \item nessuna delle due operazioni venga effettuata.
\end{itemize}

Per ottenere questo comportamento, il DBMS utilizza meccanismi di gestione delle \textbf{transazioni}, che permettono di annullare automaticamente le operazioni incomplete e ripristinare uno stato consistente dei dati.

\subsection*{Sicurezza}
Un DBMS deve proteggere i dati da accessi non autorizzati.  
Non tutti gli utenti devono poter leggere o modificare tutte le informazioni presenti nel database.

Per questo motivo, i DBMS implementano sistemi di autorizzazione basati su permessi, che stabiliscono:
\begin{itemize}
    \item quali dati un utente può visualizzare;
    \item quali operazioni può eseguire (lettura, inserimento, modifica, cancellazione).
\end{itemize}


%\subsubsection*{Proprietà ACID (da non mettere qui)}
%Per garantire l’integrità dei dati, un DBMS si basa sul concetto di transazione: una sequenza %di operazioni che deve essere completata interamente oppure annullata completamente in caso di %errore. Le proprietà fondamentali delle transazioni sono note con l’acronimo \textbf{ACID}:
%
%\begin{itemize}
%    \item \textbf{Atomicità:} ogni transazione è indivisibile; o viene completata %completamente, o non ha alcun effetto.
%    \item \textbf{Coerenza:} le transazioni portano il database da uno stato valido a un altro %stato valido.
%    \item \textbf{Isolamento:} le operazioni eseguite da un utente non interferiscono con %quelle di altri utenti fino al completamento della transazione.
%    \item \textbf{Durabilità:} una volta confermate, le modifiche ai dati rimangono permanenti %anche in caso di guasti del sistema.
%\end{itemize}
%
%\begin{center}
%\begin{tikzpicture}[node distance=2cm, every node/.style={draw, rounded corners, align=center, %minimum width=3cm, minimum height=1cm}]
%    % Nodo centrale
%    \node[fill=yellow!30] (ACID) {Transazione ACID};
%
%    % Ramificazioni
%    \node [above left=of ACID, fill=green!20] (A) {Atomicità};
%    \node [above right=of ACID, fill=green!20] (C) {Coerenza};
%    \node [below left=of ACID, fill=green!20] (I) {Isolamento};
%    \node [below right=of ACID, fill=green!20] (D) {Durabilità};
%
%    % Frecce
%    \draw[->, thick] (ACID) -- (A);
%    \draw[->, thick] (ACID) -- (C);
%    \draw[->, thick] (ACID) -- (I);
%    \draw[->, thick] (ACID) -- (D);
%\end{tikzpicture}
%\end{center}

\newpage
%==============================================================================
\section{L'astrazione fornita dai DBMS}
%==============================================================================


I Database Management System (DBMS) sono progettati secondo una \textbf{struttura a livelli di astrazione}, che consente di separare nettamente le problematiche legate alla memorizzazione fisica dei dati da quelle relative alla loro organizzazione logica e alla loro presentazione agli utenti o alle applicazioni.

Questa architettura a livelli permette a chi utilizza il database (sia persone sia programmi) di \textbf{interagire con i dati senza doversi preoccupare di come essi sono effettivamente salvati nei dispositivi di memoria}. In altre parole, gli utenti possono concentrarsi su \textit{cosa} vogliono ottenere dal database, senza dover sapere \textit{come} i dati sono archiviati o gestiti internamente. Ad esempio possono chiedere \textit{"dammi i dati di tutti i clienti"} oppure \textit{"dammi i prodotti più venduti questo mese"}, e non dire \textit{recupera dati dal file x}.


\begin{figure}[!h]
    \centering
    \includegraphics[width=1\textwidth]{images/language dbms.png}
    \caption{Ogni utente/applicazione interagisce con il DBMS tramite un linguaggio specifico che nasconde dettagli}
\end{figure}


\subsection{Livelli di astrazione di un DBMS}
\begin{enumerate}
    \item \textbf{Livello Fisico:} È il livello più basso. Riguarda come i dati sono effettivamente memorizzati nei file su disco. A questo livello si gestiscono dettagli tecnici come la compressione, la disposizione dei record nei file, le strategie di accesso rapido. Gli utenti e gli sviluppatori di applicazioni in genere non si occupano di questo livello, che è gestito direttamente dal DBMS.
    \item \textbf{Livello Logico:} Descrive la struttura logica globale del database e non dipende dai dettagli fisici di memorizzazione. Si parla di tabelle, attributi, relazioni e vincoli. Gli sviluppatori e i progettisti del database lavorano principalmente a questo livello, definendo schemi, relazioni e regole che modellano la realtà da rappresentare.
    \item \textbf{Livello Esterno (o delle Viste):} È il livello più vicino agli \textbf{utenti e alle applicazioni}. Qui si definiscono le ``\textbf{viste}'' personalizzate, cioè porzioni del database che ciascun utente può vedere e manipolare. Ogni utente/applicazione può avere una vista diversa, limitata ai dati che gli servono o che è autorizzato a consultare. Questo livello è fondamentale per la sicurezza e la semplicità d’uso.
\end{enumerate}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.4\textwidth]{images/three-levels-database-architecture.jpg}
    \caption{La struttura a tre livelli di un DBMS}
\end{figure}



\subsection*{Livello Logico di un DBMS}
Il livello logico descrive \textbf{come i dati sono organizzati e strutturati, indipendentemente da come vengono memorizzati fisicamente}. 
Questo livello è fondamentale perché definisce la \textbf{struttura globale} del database, ovvero lo \textbf{schema logico}, che rappresenta la realtà che si vuole modellare (ad esempio: utenti, prodotti, ordini, ecc.).

In pratica, il livello logico permette di modellare la realtà in modo astratto e indipendente dai dettagli tecnici di memorizzazione. Questo favorisce la \textbf{modularità} e la \textbf{manutenibilità} del database: è possibile modificare la struttura fisica dei dati senza cambiare la loro organizzazione logica, e viceversa.

Il modello più comune è il  \textbf{modello relazionale}, che utilizza \textbf{relazioni} (tabelle) per rappresentare le informazioni.

\subsubsection*{Esempio}  
Supponiamo di avere un social network. Nel modello relazionale, potremmo avere la seguente tabella per gestire e memorizzare gli utenti:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Codice Utente} & \textbf{Nome} & \textbf{Cognome} & \textbf{Email} \\
\hline
1 & Marco & Rossi & marco.rossi@mail.com \\
2 & Anna & Bianchi & anna.bianchi@mail.com \\
3 & Luca & Verdi & luca.verdi@mail.com \\
\hline
\end{tabular}

\end{center}
 
\subsection{Il linguaggio dei DBMS}
Per interagire con un database, il linguaggio più diffuso è \textbf{SQL} (Structured Query Language), che consente di comunicare con il DBMS in maniera semplice e orientata ai dati.

Il linguaggio SQL è utilizzato da tutti i database relazionali, anche se con alcune variazioni specifiche per ciascun DBMS (ad esempio MySQL, PostgreSQL, Oracle, SQL Server). Basta quindi imparare un solo linguaggio per poter lavorare con diversi sistemi di basi di dati.


SQL si suddivide in tre principali categorie di comandi:

\begin{itemize}
    \item \textbf{DDL (Data Definition Language):} comandi per definire e modificare la struttura del database, ad esempio \texttt{CREATE TABLE}, \texttt{ALTER TABLE}, \texttt{DROP TABLE}.
    \item \textbf{DML (Data Manipulation Language):} comandi per inserire, aggiornare e cancellare i dati nelle tabelle, ad esempio \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE}.
    \item \textbf{DQL (Data Query Language):} comandi per interrogare il database e ottenere informazioni, principalmente tramite \texttt{SELECT}.
\end{itemize}

Grazie a SQL, è possibile lavorare direttamente sui dati in modo astratto e uniforme, senza dover conoscere i dettagli fisici di memorizzazione, come file o indici su disco.



\newpage
\newpage
\section{Il modello relazionale}
%==============================================================================

Il modello relazionale è stato introdotto negli anni '70 dal professor \textbf{Edgar F. Codd} presso IBM.  
La sua idea rivoluzionaria era di rappresentare le informazioni tramite tabelle (relazioni) anziché attraverso strutture ad hoc o file sequenziali.  
I database che seguono questo modello sono chiamati \textbf{RDBMS} (Relational Database Management System) e costituiscono ancora oggi lo standard per la maggior parte delle applicazioni professionali.

L'idea principale del modello relazionale è semplice: rappresentare le informazioni tramite \textbf{tabelle}, chiamate \textbf{relazioni}, dove ogni riga corrisponde a un oggetto reale e ogni colonna a una proprietà di quell'oggetto.


Per rendere l'idea, consideriamo un contesto scolastico. Gli oggetti principali sono studenti, materie e voti.  

\begin{itemize}
    \item \textbf{Studente:} identificato da matricola, nome e cognome.
    \item \textbf{Materia:} identificata da codice e nome.
    \item \textbf{Voto:} associa uno studente a una materia in un certo periodo, con il punteggio ottenuto.
\end{itemize}

Rappresentiamo queste entità come tabelle:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 & Anna & Bianchi \\
103 & Luca & Verdi \\
\hline
\end{tabular}
\hspace{1cm}
\begin{tabular}{|c|c|}
\hline
\textbf{Codice} & \textbf{Materia} \\
\hline
MAT01 & Matematica \\
INF02 & Informatica \\
FIS03 & Fisica \\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Codice Materia} & \textbf{Voto} \\
\hline
101 & MAT01 & 8 \\
102 & INF02 & 7 \\
103 & FIS03 & 9 \\
\hline
\end{tabular}
\end{center}

In termini formali del modello relazionale, la tabella è chiamata \textbf{relazione}.  
Le colonne della tabella sono chiamate \textbf{attributi}, mentre le righe corrispondono alle \textbf{tuple} o \textbf{istanze della relazione}.  
La relazione ha uno \textbf{schema}, che definisce i nomi degli attributi e i tipi di dati associati. Lo schema resta fisso, mentre le istanze della relazione possono cambiare nel tempo.

Queste tabelle rappresentano la \textbf{struttura logica} dei dati: ogni riga è una \textbf{tupla}, ogni colonna un \textbf{attributo}, e insieme formano una relazione.

\subsubsection*{Schema e istanza}

Lo \textbf{schema} della relazione definisce i nomi delle colonne e i tipi di dati, ad esempio:
\begin{center}
\code{Studente(Matricola, Nome, Cognome)}
\end{center}
L'\textbf{istanza} della relazione è l'insieme delle righe effettivamente presenti in un certo momento:
\begin{center}
\code{(101, Marco, Rossi), (102, Anna, Bianchi), (103, Luca, Verdi)}
\end{center}


Questa distinzione tra schema e istanza è fondamentale: lo schema descrive la struttura, mentre l'istanza è ciò che contiene i dati reali.

\subsubsection*{Vincoli sull'ordine dei dati}
È importante sottolineare che nel modello relazionale non esistono vincoli sull'ordine dei dati: 
l'ordinamento delle righe è irrilevante, così come l'ordinamento delle colonne.  
Una relazione è definita dal contenuto delle tuple e dagli attributi, non dalla loro posizione nella tabella.


\subsubsection*{Vincoli sulla relazione}
na relazione ha alcune regole fondamentali:

\begin{itemize}
    \item \textbf{Ogni attributo deve essere unico:} non possono esistere due colonne con lo stesso nome all'interno della stessa relazione.
    \item \textbf{Ogni tupla deve essere unica:} non possono esistere due righe identiche all'interno della relazione.
    \item \textbf{Omogeneità dei dati per colonna:} tutti i valori di una colonna devono appartenere allo stesso dominio (tipo di dato).  
    \textbf{Esempio:} nella colonna \texttt{Matricola} devono esserci solo numeri interi, mentre nella colonna \texttt{Nome} solo stringhe di testo.
\end{itemize}

\subsection{Formalizzazione del Modello Relazionale}
Il termine \textbf{relazione} non è casuale: deriva dalla \textit{teoria degli insiemi} in matematica.  
In matematica, una relazione tra insiemi è un insieme di n-uple ordinate, che collegano elementi di insiemi diversi.  
Allo stesso modo, una tabella in un database relazionale rappresenta un insieme di tuple che collegano valori di attributi, ciascuno dei quali appartiene a un dominio specifico.

\subsubsection{Definizione di Relazione}

Sia dato un insieme finito di attributi \( \{A_1, A_2, \dots, A_n\} \), 
dove ciascun attributo \(A_i\) è associato a un dominio \(D_i\) di valori possibili.


\vspace{0.5cm}

Una \textbf{relazione} \(R\) su questi attributi è un insieme di tuple \(t\) tali che
\[
t = (v_1, v_2, \dots, v_n), \quad \text{con } v_i \in D_i \text{ per } i=1,\dots,n.
\]

\vspace{0.2cm}

In altre parole, una relazione è un sottoinsieme del prodotto cartesiano dei domini:
\[
R \subseteq D_1 \times D_2 \times \dots \times D_n
\]
\textbf{Nota:}  
\begin{itemize}

    \item Ogni tupla \(t \in R\) corrisponde a una riga della relazione.  

    \item Ogni attributo \(A_i\) corrisponde a una colonna.  

    \item Non ci sono tuple duplicate: \(R\) è un insieme.  

    \item Lo schema della relazione è dato dall'insieme \(\{A_1, A_2, \dots, A_n\}\) e dai domini associati \(\{D_1, D_2, \dots, D_n\}\).
\end{itemize}
\textbf{Esempio:} consideriamo due insiemi
\[
A = \{101, 102, 103\}, \quad B = \{\text{Matematica}, \text{Informatica}, \text{Fisica}\}
\]
e una relazione \texttt{Voto} tra studenti e materie:
\[
\text{Voto} = \{ (101, \text{Matematica}, 8), (102, \text{Informatica}, 7), (103, \text{Fisica}, 9) \}
\]
Ogni tupla associa uno studente a una materia e a un voto, proprio come una n-upla matematica.


%==============================================================================
%==============================================================================
%==============================================================================

\subsection{Vincoli d'integrità intra-relazionali}
%==============================================================================

Nel modello relazionale, oltre a definire gli attributi e le tuple, è fondamentale imporre regole che garantiscano **l'unicità e la coerenza dei dati**. Queste regole si chiamano \textbf{vincoli d'integrità}.

% Vincoli di tupla
\subsubsection{Vincoli di tupla}

I \textbf{vincoli di tupla} (o vincoli di ennupla) impongono condizioni che devono essere soddisfatte \textbf{da ogni singola tupla} della relazione, indipendentemente dalle altre.

Questi vincoli riguardano:
\begin{itemize}
    \item il \textbf{dominio} dei valori ammessi;
    \item la \textbf{presenza obbligatoria} di un valore (non nullo);
    \item eventuali \textbf{intervalli o condizioni logiche}.
\end{itemize}

\textbf{Esempio 1 -- Vincolo di dominio:}

Relazione \texttt{Voto(Matricola, CodiceMateria, Voto)}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{CodiceMateria} & \textbf{Voto} \\
\hline
101 & MAT01 & 8 \\
102 & INF02 & 11 \\
103 & FIS03 & 9 \\
\hline
\end{tabular}
\end{center}

Il valore \texttt{11} viola il vincolo di tupla, perché il voto deve appartenere all’intervallo \([0,10]\).

\bigskip

\textbf{Esempio 2 -- Vincolo di non nullità:}

Relazione \texttt{Studente(Matricola, Nome, Cognome)}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 &  & Bianchi \\
103 & Luca & Verdi \\
\hline
\end{tabular}
\end{center}

La seconda tupla viola il vincolo di tupla perché l’attributo \texttt{Nome} non può essere vuoto o nullo.

\bigskip

In generale, un vincolo di tupla deve essere verificato \textbf{per ogni riga singolarmente}, senza confrontarla con le altre tuple della relazione.
\subsubsection{Vincoli di chiave (Primary Key)}

Nel modello relazionale, il concetto di \textbf{chiave} nasce dall’esigenza di identificare in modo univoco le ennuple (tuple) di una relazione. Infatti per \textbf{chiave di una relazione} si intende un insieme di attributi che consente di identificare in maniera univoca le ennuple di una relazione.\mbox{}\\\\
Per essere più precisi, definiamo due concetti fondamentali:
\begin{itemize}
    
    \item \textbf{Superchiave}: una superchiave è un insieme di attributi che identifica in modo univoco le ennuple di una relazione, ma che può contenere attributi ridondanti, cioè non strettamente necessari all’identificazione.
    
    \item \textbf{Superchiave minimale}: una superchiave minimale è una superchiave tale che non esiste un’altra superchiave \(K'\) contenuta in essa.
    In altre parole, è una superchiave priva di attributi superflui.
\end{itemize}\\\\
\textbf{Esempio:} consideriamo la relazione \texttt{Studente(Matricola, Nome, Cognome)}.


% Esempio tabulare delle tuple della relazione Studente
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 & Anna & Bianchi \\
103 & Luca & Verdi \\
104 & Anna & Verdi \\
\hline
\end{tabular}
\end{center}
\begin{itemize}
    \item \{\texttt{Matricola}\} è una superchiave minimale, quindi una chiave.
    \item \{\texttt{Matricola, Nome}\} è una superchiave, ma non minimale.
    \item \{\texttt{Matricola, Nome, Cognome}\} è ancora una superchiave, ma contiene attributi ridondanti.
\end{itemize}
Una relazione può avere più chiavi (superchiavi minimali). Tra queste, una viene scelta come \textbf{chiave primaria}.



\subsubsection*{Esiste sempre almeno una superchiave per ogni relazione?}

\textbf{Sì.}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 & Anna & Bianchi \\
103 & Luca & Verdi \\
\hline
\end{tabular}
\end{center}
L’insieme di tutti gli attributi della relazione, in questo caso \{\texttt{Matricola, Nome, Cognome}\} è sempre una superchiave.

\bigskip

\subsubsection*{Possono esistere più superchiavi per la stessa relazione?}

\textbf{Sì.}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 & Anna & Bianchi \\
103 & Luca & Verdi \\
\hline
\end{tabular}
\end{center}
Sono superchiavi:
\begin{itemize}
    \item \{\texttt{Matricola}\}
    \item \{\texttt{Matricola, Nome}\}
    \item \{\texttt{Matricola, Cognome}\}
    \item \{\texttt{Matricola, Nome, Cognome}\}
\end{itemize}

\bigskip

\subsubsection*{Esiste sempre almeno una chiave per ogni relazione?}

\textbf{Sì.}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 & Anna & Bianchi \\
103 & Luca & Verdi \\
\hline
\end{tabular}
\end{center}

L’attributo \texttt{Matricola} identifica univocamente ogni tupla ed è una superchiave minimale, quindi una chiave.

\bigskip

\subsubsection*{Possono esistere più chiavi per la stessa relazione?}

\textbf{Sì.}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{CodiceUtente} & \textbf{Email} & \textbf{Username} \\
\hline
U001 & marco@mail.com & marcoR \\
U002 & anna@mail.com & annaB \\
U003 & luca@mail.com & lucaV \\
\hline
\end{tabular}
\end{center}

In questa relazione sono chiavi:
\begin{itemize}
    \item \{\texttt{CodiceUtente}\}
    \item \{\texttt{Email}\}
    \item \{\texttt{Username}\}
\end{itemize}
Una di queste viene scelta come chiave primaria.


\newpage
\subsection{Vincoli d'integrità inter-relazionali}

\subsubsection{Chiavi esterne (Foreign Key)}

Una chiave esterna è un tipo di vincolo referenziale che garantisce che i valori inseriti all'interno di una relazione corrispondano ai valori inseriti all'interno di un'atra relazione, mantenendo così l'integrità referenziale del database.

\paragraph{Passo 1 -- Relazioni separate}\mbox{}\\
 Nel modello relazionale, una base di dati è in genere composta da \textbf{più relazioni} collegate tra loro.  

\vspace{0.5cm}
\textbf{Studente}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} \\
\hline
101 & Marco & Rossi \\
102 & Anna & Bianchi \\
103 & Luca & Verdi \\
\hline
\end{tabular}
\end{center}

\textbf{Materia}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{CodiceMateria} & \textbf{NomeMateria} \\
\hline
MAT01 & Matematica \\
INF02 & Informatica \\
FIS03 & Fisica \\
\hline
\end{tabular}
\end{center}
In entrambe le relazioni, \texttt{Matricola} e \texttt{CodiceMateria} sono chiavi primarie.

\paragraph{Passo 2 -- Relazione che collega le altre}\mbox{}\\
Introduciamo ora una terza relazione che collega studenti e materie:

\vspace{0.5cm}
\textbf{Voto}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{CodiceMateria} & \textbf{Voto} \\
\hline
101 & MAT01 & 8 \\
102 & INF02 & 7 \\
103 & FIS03 & 9 \\
101 & INF02 & 9 \\
\hline
\end{tabular}
\end{center}


\paragraph{Passo 3 -- Identificazione delle chiavi esterne}\mbox{}\\
Nella relazione \texttt{Voto}:
\begin{itemize}
    \item \texttt{Matricola} è una \textbf{chiave esterna} che fa riferimento alla chiave primaria \texttt{Matricola} della relazione \texttt{Studente};
    \item \texttt{CodiceMateria} è una \textbf{chiave esterna} che fa riferimento alla chiave primaria \texttt{CodiceMateria} della relazione \texttt{Materia}.
\end{itemize}

\bigskip
\paragraph{Perché servono le chiavi esterne}\mbox{}\\
Le chiavi esterne garantiscono l’\textbf{integrità referenziale}, cioè:
\begin{itemize}
    \item non è possibile inserire un voto per uno studente che non esiste;
    \item non è possibile inserire un voto per una materia che non esiste.
\end{itemize}
Ogni valore di chiave esterna deve quindi corrispondere a un valore esistente nella relazione di riferimento.














%====================================================================
%====================================================================
%====================================================================
\newpage
\newpage
\newpage
\newpage
%====================================================================
%====================================================================
%====================================================================
\section{Progettazione di una base di dati}
%====================================================================

La progettazione di una base di dati non è un’attività improvvisata, ma segue una metodologia precisa.

\subsection{Analisi dei requisiti}

In questa fase si raccolgono le informazioni sul problema, si chiariscono le esigenze degli utenti e si definiscono gli obiettivi del sistema.

\subsection{Progettazione concettuale}

Si costruisce una rappresentazione astratta della realtà, indipendente dal DBMS.  
In questa fase si privilegia la chiarezza rispetto ai dettagli tecnici.

\subsection{Progettazione logica}

Il modello concettuale viene tradotto nel modello relazionale.  
Si definiscono tabelle, chiavi e vincoli.

\subsection{Progettazione fisica}

Si decide come i dati saranno memorizzati e ottimizzati dal DBMS.

%====================================================================
\section{Dal modello relazionale a SQL}
%====================================================================

Il linguaggio SQL è stato progettato per operare direttamente sul modello relazionale.

Ogni comando SQL ha una motivazione teorica ben precisa.

SQL è un linguaggio dichiarativo: descrive il risultato desiderato, non il procedimento.

Questa caratteristica permette al DBMS di ottimizzare le operazioni e garantire l’indipendenza dei dati.

\newpage

% ==========================
%         ESERCIZI
% ==========================
\thispagestyle{empty}
\begin{center}
    \vspace*{5cm}
    {\Huge\bfseries Esercizi}
\end{center}
\newpage


% ==========================
\section{Esercizi -- Modello relazionale}
% ==========================

\begin{enumerate}

% Esercizio 1 fornito dall'utente
\item \textbf{Esercizio 1}

Considera la seguente tabella \texttt{Libro}:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Codice} & \textbf{Titolo} & \textbf{Autore} & \textbf{Anno} \\
\hline
L01 & Il nome della rosa & Umberto Eco & 1980 \\
L02 & Il fu Mattia Pascal & Luigi Pirandello & 1904 \\
L03 & Se questo è un uomo & Primo Levi & 1947 \\
L04 & Il barone rampante & Italo Calvino & 1957 \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Quale attributo può essere scelto come chiave primaria? Motiva la risposta.
    \item Esistono superchiavi diverse dalla chiave primaria? Fai almeno un esempio.
    \item È possibile che la combinazione \{\texttt{Titolo}, \texttt{Autore}\} sia una chiave primaria? Quando?
\end{enumerate}

\vspace{0.5cm}

% Esercizio 2 fornito dall'utente
\item \textbf{Esercizio 2}

Considera la seguente relazione \texttt{Prenotazione}:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{IDPrenotazione} & \textbf{Data} & \textbf{Ora} & \textbf{Tavolo} \\
\hline
1 & 2024-05-10 & 20:00 & 12 \\
2 & 2024-05-10 & 21:00 & 7 \\
3 & 2024-05-11 & 19:30 & 5 \\
4 & 2024-05-11 & 21:00 & 12 \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Indica una possibile chiave primaria per la relazione.
    \item La combinazione \{\texttt{Data}, \texttt{Ora}, \texttt{Tavolo}\} può essere una chiave candidata? Motiva la risposta.
    \item Esistono attributi che possono assumere valori nulli? Spiega.
\end{enumerate}

\vspace{0.5cm}

% Esercizio 3 fornito dall'utente
\item \textbf{Esercizio 3}

Considera la seguente tabella \texttt{Film}:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{CodiceFilm} & \textbf{Titolo} & \textbf{Regista} & \textbf{Anno} \\
\hline
F01 & La vita è bella & Roberto Benigni & 1997 \\
F02 & Il postino & Michael Radford & 1994 \\
F03 & Nuovo Cinema Paradiso & Giuseppe Tornatore & 1988 \\
F04 & La grande bellezza & Paolo Sorrentino & 2013 \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Quali tra i seguenti insiemi di attributi possono essere superchiavi? Motiva la risposta.\\
    a) \{\texttt{CodiceFilm}\} \\
    b) \{\texttt{Titolo}, \texttt{Regista}\} \\
    c) \{\texttt{Anno}, \texttt{Titolo}\}
    \item Indica tutte le possibili chiavi primarie.
\end{enumerate}

\vspace{0.5cm}

% Esercizio originale 4
\item \textbf{Esercizio 4}

Osserva la seguente relazione \texttt{Studente}:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Matricola} & \textbf{Nome} & \textbf{Cognome} & \textbf{Email} \\
\hline
101 & Sara & Neri & sara.neri@mail.com \\
102 & Luca & Bianchi & luca.bianchi@mail.com \\
103 & Marco & Verdi & marco.verdi@mail.com \\
104 & Sara & Neri & sara.neri2@mail.com \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Quale attributo può essere scelto come chiave primaria? Motiva la risposta.
    \item La combinazione \{\texttt{Nome}, \texttt{Cognome}\} può essere chiave? Perché?
    \item Esistono superchiavi composte da più attributi? Fai un esempio.
    \item L’attributo \texttt{Email} può essere chiave? In quali condizioni?
\end{enumerate}

\vspace{0.5cm}

% Esercizio originale 5
\item \textbf{Esercizio 5}

Considera la tabella \texttt{Ordine}:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{NumeroOrdine} & \textbf{Data} & \textbf{Cliente} & \textbf{Importo} \\
\hline
5001 & 2024-06-01 & Rossi & 120.00 \\
5002 & 2024-06-02 & Bianchi & 85.50 \\
5003 & 2024-06-02 & Neri & 42.00 \\
5004 & 2024-06-03 & Rossi & 75.00 \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Qual è la chiave primaria più naturale per questa relazione?
    \item La coppia \{\texttt{Data}, \texttt{Cliente}\} può essere una chiave? Giustifica.
    \item Se possono esistere più ordini nello stesso giorno per lo stesso cliente, quali attributi dovresti usare per identificare univocamente ogni ordine?
\end{enumerate}

\vspace{0.5cm}

% Esercizio originale 6
\item \textbf{Esercizio 6}

Osserva la seguente tabella \texttt{PrenotazioneHotel}:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{IDPrenotazione} & \textbf{Cliente} & \textbf{Camera} & \textbf{DataInizio} & \textbf{DataFine} \\
\hline
10 & Verdi & 201 & 2024-07-01 & 2024-07-05 \\
11 & Bianchi & 105 & 2024-07-02 & 2024-07-03 \\
12 & Neri & 201 & 2024-07-06 & 2024-07-10 \\
13 & Verdi & 105 & 2024-07-10 & 2024-07-12 \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Quale attributo può essere scelto come chiave primaria? Esistono altre possibilità?
    \item La combinazione \{\texttt{Camera}, \texttt{DataInizio}\} può essere una chiave? In quali condizioni?
    \item L’attributo \texttt{Cliente} può essere chiave? Perché?
\end{enumerate}

\vspace{0.5cm}

% Esercizio originale 7
\item \textbf{Esercizio 7}

Considera la tabella \texttt{IscrizioneCorso}:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Matricola} & \textbf{CodiceCorso} & \textbf{DataIscrizione} \\
\hline
201 & INF01 & 2024-09-01 \\
202 & MAT02 & 2024-09-01 \\
201 & MAT02 & 2024-09-02 \\
203 & INF01 & 2024-09-03 \\
\hline
\end{tabular}
\end{center}

\begin{enumerate}
    \item Quale insieme di attributi può essere scelto come chiave primaria?
    \item Esistono altre superchiavi? Forniscine almeno una.
    \item L’attributo \texttt{DataIscrizione} può essere chiave? Perché?
\end{enumerate}

\item \textbf{Esercizio 8}

Dato lo schema relazionale seguente:

\begin{itemize}
    \item \texttt{AGENZIA(Nome, Indirizzo, Telefono)}
    \item \texttt{CASA(Indirizzo, NrInterno, CodProprietario, Prezzo)}
    \item \texttt{INSERZIONI(Codice, IndirizzoCasa, InternoCasa, NomeAgenzia, \\DataInserzione)}
    \item \texttt{PROPRIETARIO(Codice, Nome, Cognome, Telefono)}
\end{itemize}

\textbf{Richiesta:} Individuare i vincoli di integrità referenziale presenti tra le relazioni.

\end{enumerate}

\end{document}